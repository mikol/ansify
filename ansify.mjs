const formatterProperties = [
  // Modifiers

  ['bold', 1, 22],
  ['dim', 2, 22],
  ['hidden', 8, 28],
  ['inverse', 7, 27],
  ['italic', 3, 23],
  ['overline', 53, 55],
  ['reset', 0, 0],
  ['strikethrough', 9, 29],
  ['underline', 4, 24],

  // Colors

  ['black', 30, 39],
  ['blue', 34, 39],
  ['cyan', 36, 39],
  ['gray', 90, 39],
  ['green', 32, 39],
  ['grey', 90, 39],
  ['magenta', 35, 39],
  ['red', 31, 39],
  ['white', 37, 39],
  ['yellow', 33, 39],

  // Bright Colors

  ['brightBlack', 90, 39],
  ['blackBright', 90, 39],
  ['brightBlue', 94, 39],
  ['blueBright', 94, 39],
  ['brightCyan', 96, 39],
  ['cyanBright', 96, 39],
  ['brightGreen', 92, 39],
  ['greenBright', 92, 39],
  ['brightMagenta', 95, 39],
  ['magentaBright', 95, 39],
  ['brightRed', 91, 39],
  ['redBright', 91, 39],
  ['brightWhite', 97, 39],
  ['whiteBright', 97, 39],
  ['brightYellow', 93, 39],
  ['yellowBright', 93, 39],

  // Background Colors

  ['blackBg', 40, 49],
  ['bgBlack', 40, 49],
  ['blueBg', 44, 49],
  ['bgBlue', 44, 49],
  ['cyanBg', 46, 49],
  ['bgCyan', 46, 49],
  ['grayBg', 100, 49],
  ['bgGray', 100, 49],
  ['greenBg', 42, 49],
  ['bgGreen', 42, 49],
  ['greyBg', 100, 49],
  ['bgGrey', 100, 49],
  ['magentaBg', 45, 49],
  ['bgMagenta', 45, 49],
  ['redBg', 41, 49],
  ['bgRed', 41, 49],
  ['whiteBg', 47, 49],
  ['bgWhite', 47, 49],
  ['yellowBg', 43, 49],
  ['bgYellow', 43, 49],

  // Bright Background Colors

  ['brightBlackBg', 100, 49],
  ['bgBlackBright', 100, 49],
  ['brightBlueBg', 104, 49],
  ['bgBlueBright', 104, 49],
  ['brightCyanBg', 106, 49],
  ['bgCyanBright', 106, 49],
  ['brightGreenBg', 102, 49],
  ['bgGreenBright', 102, 49],
  ['brightMagentaBg', 105, 49],
  ['bgMagentaBright', 105, 49],
  ['brightRedBg', 101, 49],
  ['bgRedBright', 101, 49],
  ['brightWhiteBg', 107, 49],
  ['bgWhiteBright', 107, 49],
  ['brightYellowBg', 103, 49],
  ['bgYellowBright', 103, 49],

  // Decorative

  ['decorative', null, null],
  ['visible', null, null],

  // ANSI 256

  ['ansi256', 38, 39, makeAnsi256FormatGetter],
  ['ansi256Bg', 48, 49, makeAnsi256FormatGetter],
  ['bgAnsi256', 48, 49, makeAnsi256FormatGetter],

  // True Color (Hex)

  ['hex', 38, 39, makeHexFormatGetter],
  ['hexBg', 48, 49, makeHexFormatGetter],
  ['bgHex', 48, 49, makeHexFormatGetter],

  // True Color (RGB)

  ['rgb', 38, 39, makeRgbFormatGetter],
  ['rgbBg', 48, 49, makeRgbFormatGetter],
  ['bgRgb', 48, 49, makeRgbFormatGetter]
].reduce((o, [name, head, tail, make = makeFormatGetter]) => {
  o[name] = {configurable: true, get: make(name, head, tail)}
  return o
}, {})

const hasColorsFunction = typeof process.stdout.hasColors === 'function'
  && typeof process.stderr.hasColors === 'function'

const has16 = hasColorsFunction ? process.stdout.hasColors() : true
const errHas16 = hasColorsFunction ? process.stderr.hasColors() : true

const has256 = hasColorsFunction && process.stdout.hasColors(2 ** 8)
const errHas256 = hasColorsFunction && process.stderr.hasColors(2 ** 8)

const hasRgb = hasColorsFunction && process.stdout.hasColors(2 ** 24)
const errHasRgb = hasColorsFunction && process.stderr.hasColors(2 ** 24)

// -----------------------------------------------------------------------------
// Applied Formatting

/**
 * Joins one or more strings specified by `input` with spaces, encloses the
 * resulting string with opening and closing escape codes, and fixes up the
 * output to ensure that styles are applied consistently and as expected.
 *
 * @param {Array<string>} input - The string to interpolate.
 * @param {function(...*):string} format - An ANSI escape code formatter
 *     as generated by `makeFormatGetter()`.
 */
function applyFormat(input, format) {
  // XXX: Although the following functionality could have been included within
  // the `ansify()` implementation, doing so would have required the use of
  // `ansify.call()`, which is less performant than an ordinary function call.

  const shouldAnsify = format.colors.has16 === true
    || format.colors.has256 === true
    || format.colors.hasRgb === true

  let output = input.length === 1 ? '' + input[0] : input.join(' ')

  if (shouldAnsify && output.length > 0) {
    const head = typeof format.head === 'string' ? format.head : ''
    const tail = typeof format.tail === 'string' ? format.tail : ''

    // Reopen any existing escape sequences that might conflict with the
    // specified `head` and `tail` sequences.
    output = escapeCodes(output, format)

    // Ensure escape sequences end before line breaks and begin again after.
    output = escapeLines(output, head, tail)

    output = `${head}${output}${tail}`
  } else if (format.none === true) {
    output = ''
  }

  return output
}

/**
 * Replaces all closing escape codes in `input` with closing codes followed by
 * opening codes.
 *
 * @param {string} input - The string to interpolate.
 * @param {function(...*):string} format - An ANSI escape code formatter
 *     as generated by `makeFormatGetter()`.
 *
 * @returns {string} A new string interpolated from `input` so that any existing
 *     escape code closures are reopened if they match an escape sequence
 *     discovered while recursively searching the current chain of styles.
 *
 * @see makeFormatGetter()
 */
function escapeCodes(input, format) {
  if (input.indexOf('\x1b') > -1) {
    while (format != null) {
      if (format.data != null) {
        input = replaceCodes(input, format.data[0], format.data[1])
      }

      format = format.prev
    }
  }

  return input
}

/**
 * Interpolates `input`, ensuring that escapes sequences are closed before line
 * breaks and reopened after them.
 *
 * @param {string} input - The string to interpolate.
 * @param {string} head - An opening ANSI escape code.
 * @param {string} tail - The corresponding closing ANSI escape code.
 *
 * @returns {string} A new string interpolated from `input` so that any escape
 *     sequences terminate before line breaks and reopen after them.
 */
function escapeLines(input, head, tail) {
  let index = input.indexOf('\n')

  if (index === -1) {
    return input
  }

  let startIndex = 0
  let output = ''

  while (index > -1) {
    if (input[index - 1] === '\r') {
      output += `${input.slice(startIndex, index - 1)}${tail}\r\n${head}`
    } else {
      output += `${input.slice(startIndex, index)}${tail}\n${head}`
    }

    startIndex = index + 1
    index = input.indexOf('\n', startIndex)
  }

  return output + input.slice(startIndex)
}

/**
 * Replaces `tail` with `tail + head` escape codes in `input` so that any
 * existing escape code closures matching `tail` are reopened.
 *
 * @param {string} input - The string to interpolate.
 * @param {string} head - An opening ANSI escape code.
 * @param {string} tail - The corresponding closing ANSI escape code.
 *
 * @returns {string} A new string interpolated from `input` so that any existing
 *     escape code closures are reopened if they match the escape sequence
 *     represented by `head` and `tail`.
 */
function replaceCodes(input, head, tail) {
  return input.replaceAll(tail, `${tail}${head}`)
}

if (typeof ''.replaceAll !== 'function') {
  replaceCodes = function replaceCodes(input, head, tail) {
    return input.split(tail).join(`${tail}${head}`)
  }
}

// -----------------------------------------------------------------------------
// Getters

/**
 * Produces a getter for the named `style` with codes `head` and `tail`.
 *
 * @param {string} name - A style such as `bold` or `red`.
 * @param {number|string} head - The opening value in an escape code pair.
 * @param {number|string} tail - The closing value in an escape code pair.
 *
 * @returns {function():{function(...*):string}} A getter method that
 *     generates a formatter for `style` with codes `head` and `tail`. The
 *     formatter forms a chain with all other formatters; when called, it
 *     accepts one or more input values and produces a single string output.
 */
function makeAnsi256FormatGetter(name, head, tail) {
  const nextTail = `\x1b[${tail}m`

  return function () {
    function setAnsi256(color) {
      const nextHead = `\x1b[${head};5;${color}m`

      return chainFormatter(setAnsi256, name, nextHead, nextTail, makeFormatter())
    }

    return chainFormatter(this, name, '', '', setAnsi256)
  }
}

/**
 * Produces a getter for the named `style` with codes `head` and `tail`.
 *
 * @param {string} name - A style such as `hex` or `hexBg`.
 * @param {number|string} head - The opening value in an escape code pair.
 * @param {number|string} tail - The closing value in an escape code pair.
 *
 * @returns {function():{function(...*):string}} A getter method that
 *     generates a formatter for `style` with codes `head` and `tail`. The
 *     formatter forms a chain with all other formatters; when called, it
 *     accepts one or more input values and produces a single string output.
 */
function makeHexFormatGetter(name, head, tail) {
  const nextTail = `\x1b[${tail}m`

  return function () {
    function setHex(hex) {
      const nextHead = `\x1b[${convertHex(head, hex, setHex.colors)}m`

      return chainFormatter(setHex, name, nextHead, nextTail, makeFormatter())
    }

    return chainFormatter(this, name, '', '', setHex)
  }
}

/**
 * Produces a getter for the named `style` with codes `head` and `tail`.
 *
 * @param {string} name - A style such as `rgb` or `rgbBg`.
 * @param {number|string} head - The opening value in an escape code pair.
 * @param {number|string} tail - The closing value in an escape code pair.
 *
 * @returns {function():{function(...*):string}} A getter method that
 *     generates a formatter for `style` with codes `head` and `tail`. The
 *     formatter forms a chain with all other formatters; when called, it
 *     accepts one or more input values and produces a single string output.
 */
function makeRgbFormatGetter(name, head, tail) {
  const nextTail = `\x1b[${tail}m`

  return function () {
    function setRgb(r, g, b) {
      const nextHead = `\x1b[${convertRgb(head, r, g, b, setRgb.colors)}m`

      return chainFormatter(setRgb, name, nextHead, nextTail, makeFormatter())
    }

    return chainFormatter(this, name, '', '', setRgb)
  }
}

/**
 * Produces a getter for the named `style` with codes `head` and `tail`.
 *
 * @param {string} name - A style such as `bold` or `red`.
 * @param {number|string} head - The opening value in an escape code pair.
 * @param {number|string} tail - The closing value in an escape code pair.
 *
 * @returns {function():{function(...*):string}} A getter method that
 *     generates a formatter for `style` with codes `head` and `tail`. The
 *     formatter forms a chain with all other formatters; when called, it
 *     accepts one or more input values and produces a single string output.
 */
function makeFormatGetter(name, head, tail) {
  const nextHead = head != null && head !== '' ? `\x1b[${head}m` : ''
  const nextTail = tail != null && tail !== '' ? `\x1b[${tail}m` : ''

  return function () {
    const prev = this
    const format = chainFormatter(prev, name, nextHead, nextTail, makeFormatter())

    format.none = format.none === true || head === null && tail === null

    return format
  }
}

// -----------------------------------------------------------------------------
// Getter Helpers

/**
 * Adds chainable methods and data to `format`.
 *
 * @param {Function} prev - The previous node in the chain.
 * @param {string} name - A style such as `bold` or `red`.
 * @param {string} head - The opening value in an escape code pair.
 * @param {string} tail - The closing value in an escape code pair.
 * @param {Function} format - The formatter to be added to the chain.
 *
 * @returns {Function} `format` after it has been annotated with chainable
 *     methods and data.
 */
function chainFormatter(prev, name, head, tail, format) {
  // Store raw values and pointers. `applyFormat()` uses these to format output.
  format.colors = prev.colors
  format.data = [head, tail]
  format.none = prev.none === true
  format.prev = prev

  // Concatenating escape sequences here is more performative than doing it
  // recursively after the fact in `ansify()`.
  format.head = (prev.head != null ? prev.head : '') + head
  format.tail = tail + (prev.tail != null ? prev.tail : '')

  // XXX: Not necessary for correctness, dramatically improves performance.
  Object.defineProperty(prev, name, {configurable: true, value: format})

  // Chain ANSI escape code formatters with the returned `format()` function.
  Object.setPrototypeOf(format, root) // XXX: outperforms `.defineProperties()`.

  return format
}

/**
 * Produces a basic ANSI style formatter.
 *
 * @param {Object} colors - An object representing available output colors.
 * @param {boolean} colors.has16 - If `true`, has at least 16 output colors.
 * @param {boolean} colors.has256 - If `true`, has at least 256 output colors.
 * @param {boolean} colors.hasRgb - If `true`, has 24-bit color ouput.
 *
 * @returns {function(...*):string} A basic formatter that accepts one or
 *     more input values, applies the styles defined by the current chain, and
 *     produces a single string output.
 */
function makeFormatter(colors) {
  function format(...input) {
    return applyFormat(input, format)
  }

  format.colors = colors != null ? colors : format.colors

  return format
}

// -----------------------------------------------------------------------------
// Color Converters

// FROM: https://github.com/Qix-/color-convert/blob/master/conversions.js

function convertHex(head, hex, colors) {
  let r = 0
  let g = 0
  let b = 0

  const match = (/[a-f0-9]{6}|[a-f0-9]{3}/i).exec(hex.toString(16))

  if (match) {
    let color = match[0]

    if (match[0].length === 3) {
      color = color.split('').map((c) => c + c).join('')
    }

    const integer = parseInt(color, 16)

    r = (integer >> 16) & 0xFF
    g = (integer >> 8) & 0xFF
    b = integer & 0xFF
  }

  return convertRgb(head, r, g, b, colors)
}

function convertRgb(head, r, g, b, colors) {
  if (colors.hasRgb) {
    return `${head};2;${r};${g};${b}`
  }

  if (colors.has256) {
    return `${head};5;${convertRgbToAnsi256(r, g, b)}`
  }

  return `${convertRgbToAnsi16(head, r, g, b)}`
}

function convertRgbToAnsi16(head, r, g, b) {
  const offset = head - 38

  let value = Math.round(convertRgbToHsv(r, g, b)[2] / 50)

  let ansi = 30

  if (value === 0) {
    return ansi + offset
  }

  ansi = ansi
    + ((Math.round(b / 255) << 2)
    | (Math.round(g / 255) << 1)
    | Math.round(r / 255))

  if (value === 2) {
    ansi += 60
  }

  return ansi + offset
}

function convertRgbToAnsi256(r, g, b) {
  if (r >> 4 === g >> 4 && g >> 4 === b >> 4) {
    if (r < 8) {
      return 16
    }

    if (r > 248) {
      return 231
    }

    return Math.round(((r - 8) / 247) * 24) + 232
  }

  return 16
    + (36 * Math.round(r / 255 * 5))
    + (6 * Math.round(g / 255 * 5))
    + Math.round(b / 255 * 5)
}

function convertRgbToHsv(r, g, b) {
  r = r / 255
  g = g / 255
  b = b / 255

  let rdif
  let gdif
  let bdif
  let h
  let s

  const v = Math.max(r, g, b)
  const diff = v - Math.min(r, g, b)

  const diffc = function (c) {
    return (v - c) / 6 / diff + 1 / 2
  }

  if (diff === 0) {
    h = 0
    s = 0
  } else {
    s = diff / v
    rdif = diffc(r)
    gdif = diffc(g)
    bdif = diffc(b)

    if (r === v) {
      h = bdif - gdif
    } else if (g === v) {
      h = (1 / 3) + rdif - bdif
    } else if (b === v) {
      h = (2 / 3) + gdif - rdif
    }

    if (h < 0) {
      h += 1
    } else if (h > 1) {
      h -= 1
    }
  }

  return [
    h * 360,
    s * 100,
    v * 100
  ]
}

// -----------------------------------------------------------------------------

/**
 * The root of a chain of ANSI escape code formatters with support for colors
 * automatically detected from stdout.
 *
 * @param {...*} input - One ore more
 */
const ansify = makeFormatter({has16, has256, hasRgb})

/**
 * The root of a chain of ANSI escape code formatters with support for colors
 * automatically detected from stderr.
 */
const ansifyErr = makeFormatter({has16: errHas16, has256: errHas256, hasRgb: errHasRgb})

/** The root of a chain of 0-color ANSI escape code formatters. */
const ansify0 = makeFormatter({has16: false, has256: false, hasRgb: false})

/** The root of a chain of 16-color ANSI escape code formatters. */
const ansify16 = makeFormatter({has16: true, has256: false, hasRgb: false})

/** The root of a chain of 256-color ANSI escape code formatters. */
const ansify256 = makeFormatter({has16: true, has256: true, hasRgb: false})

/** The root of a chain of true-color ANSI escape code formatters. */
const ansifyRgb = makeFormatter({has16: true, has256: true, hasRgb: true})

// Chain ANSI escape code formatters with `ansify()`.
const root = Object.defineProperties(() => {}, formatterProperties)

Object.setPrototypeOf(ansify, root)
Object.setPrototypeOf(ansifyErr, root)

Object.setPrototypeOf(ansify0, root)
Object.setPrototypeOf(ansify16, root)
Object.setPrototypeOf(ansify256, root)
Object.setPrototypeOf(ansifyRgb, root)

export default ansify
export {ansify0, ansify16, ansify256, ansifyErr, ansifyRgb}
